{"componentChunkName":"component---src-templates-blog-post-js","path":"/study/jest/","result":{"data":{"site":{"siteMetadata":{"title":"개인 프로젝트 하는 사람","author":"soso01","siteUrl":"https://soso01.github.io","comment":{"disqusShortName":"","utterances":"JaeYeopHan/gatsby-starter-bee"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"5b2753d3-4caf-5964-a135-75ae0bf3bc51","excerpt":"Jest 강좌 출처 - 유튜브 코딩앙마 소개, 설치, 간단한 테스트 JEST : 페북에서 만듬, Zero config 철학을 가지고 있어서 별개의 설정없이 빠르게 테스트할 수 있는 장점이 있다. js진영에서 테스트 도구로 제일 많이 쓴다. npm i jest -D 설치 package.json에서 스크립트에 test : ‘jest’로 수정. npm jest 명령어를 치면 *.test.js 파일이나 tests폴더에 테스트 파일들을 모두 테스트한다. 테스트할 함수를 불러오고 expect…","html":"<h1 id=\"jest-강좌\" style=\"position:relative;\"><a href=\"#jest-%EA%B0%95%EC%A2%8C\" aria-label=\"jest 강좌 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Jest 강좌</h1>\n<h3 id=\"출처---유튜브-코딩앙마\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EC%B2%98---%EC%9C%A0%ED%8A%9C%EB%B8%8C-%EC%BD%94%EB%94%A9%EC%95%99%EB%A7%88\" aria-label=\"출처   유튜브 코딩앙마 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://www.youtube.com/watch?v=g4MdUjxA-S4&#x26;list=PLZKTXPmaJk8L1xCg_1cRjL5huINlP2JKt&#x26;index=1\">출처 - 유튜브 코딩앙마</a></h3>\n<h3 id=\"소개-설치-간단한-테스트\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EA%B0%9C-%EC%84%A4%EC%B9%98-%EA%B0%84%EB%8B%A8%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"소개 설치 간단한 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소개, 설치, 간단한 테스트</h3>\n<ul>\n<li>JEST : 페북에서 만듬, Zero config 철학을 가지고 있어서 별개의 설정없이 빠르게 테스트할 수 있는 장점이 있다.</li>\n<li>js진영에서 테스트 도구로 제일 많이 쓴다.</li>\n<li>npm i jest -D 설치</li>\n<li>package.json에서 스크립트에 test : ‘jest’로 수정.</li>\n<li>npm jest 명령어를 치면 *.test.js 파일이나 <strong>tests</strong>폴더에 테스트 파일들을 모두 테스트한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript=\"><pre class=\"language-javascript=\"><code class=\"language-javascript=\">const { add } = require(&quot;./fn&quot;)\n\ntest(&quot;2 + 3 = 5&quot;, () =&gt; {\n  expect(add(2, 3)).toBe(5)\n})</code></pre></div>\n<ul>\n<li>테스트할 함수를 불러오고 expect에 검증할 값을, toBe에 인자로 예상값을 넣고 테스트를 돌리면 expect값이 예상값과 일치한지 출력해준다.</li>\n<li>여기에 쓰인 toBe를 Matcher 라고 한다.</li>\n<li>toBe는 숫자나 문자 같은 기본 타입형을 검사할때 쓰고, toBe 외에도 다양한 Matcher가 있음.</li>\n</ul>\n<h3 id=\"다양한-matchers\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%96%91%ED%95%9C-matchers\" aria-label=\"다양한 matchers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다양한 Matchers</h3>\n<h4 id=\"tobe와-toequal의-차이\" style=\"position:relative;\"><a href=\"#tobe%EC%99%80-toequal%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-label=\"tobe와 toequal의 차이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>toBe와 toEqual의 차이</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript=\"><pre class=\"language-javascript=\"><code class=\"language-javascript=\">const { makeUser } = require(&quot;./fn&quot;)\n\ntest(&quot;Jake toBe&quot;, () =&gt; {\n  expect(makeUser(&#39;Jake&#39;, 20)).toBe({name: &#39;Jake&#39;, age: 20})\n}) // 실패\n\ntest(&quot;Jake toEqual&quot;, () =&gt; {\n  expect(makeUser(&#39;Jake&#39;, 20)).toEqual({name: &#39;Jake&#39;, age: 20})\n}) // 성공</code></pre></div>\n<ul>\n<li>\n<p>toBe는 객체나 배열의 내부를 재귀적으로 탐색하면서 비교하지 않지만, toEqual은 재귀적으로 돌면서 속성이 같은지 비교함.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript=\"><pre class=\"language-javascript=\"><code class=\"language-javascript=\">test(&quot;Jake toBe&quot;, () =&gt; {\nconst jake = {name : &#39;Jake&#39;}\nexpect(jake).toBe(jake)\n})</code></pre></div>\n</li>\n<li>이건 통과한다. toBe는 딱 js에서 ’===’ 비교랑 같은듯하다. 객체나 배열은 레퍼런스값으로만 비교한다.</li>\n</ul>\n<h4 id=\"tostrictequal\" style=\"position:relative;\"><a href=\"#tostrictequal\" aria-label=\"tostrictequal permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>toStrictEqual</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript=\"><pre class=\"language-javascript=\"><code class=\"language-javascript=\">const fn = {\n  add : (a, b) =&gt; a + b,\n  makeUser: (name, age) =&gt; ({name, age, gender: undefined})\n}\n\ntest(&quot;Jake toStrictEqual&quot;, () =&gt; {\n  expect(makeUser(&#39;Jake&#39;, 20)).toStrictEqual({name: &#39;Jake&#39;, age: 20})\n}) // 실패\n\ntest(&quot;Jake toEqual&quot;, () =&gt; {\n  expect(makeUser(&#39;Jake&#39;, 20)).toEqual({name: &#39;Jake&#39;, age: 20})\n}) // 성공</code></pre></div>\n<ul>\n<li>toStrictEqual은 toEqual보다 좀 더 엄격하게 비교연산을 수행한다.</li>\n<li>toEqual에서는 gender: undefined와 gender속성이 아예없는것을 같다고 판별하지만 toStrictEqual은 다르다고 봄.</li>\n</ul>\n<h4 id=\"그외\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EC%99%B8\" aria-label=\"그외 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그외</h4>\n<ul>\n<li>toBeNull</li>\n<li>toBeUndefined</li>\n<li>toBeDefined</li>\n<li>toBeTruthy </li>\n<li>toBeFalsy</li>\n<li>toBeGreaterThan - 크다</li>\n<li>toBeGreaterThanOrEqual - 크거나같다</li>\n<li>toBeLessThan - 작다</li>\n<li>toBeLessThanOrEqual - 작거나같다</li>\n<li>\n<p>toMatch - 정규표현식</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript=\"><pre class=\"language-javascript=\"><code class=\"language-javascript=\">test(&quot;match&quot;, () =&gt; {\nexpect(&quot;hello world&quot;).toMatch(/hello/)\n}) //성공</code></pre></div>\n</li>\n<li>toContain - 배열에서 특정요소가 있는지 확인</li>\n<li>toThrow - 에러 발생 여부. 인자에 에러 메시지 넣어서 메시지검증까지도 됨.</li>\n</ul>\n<h3 id=\"비동기-코드-테스트\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%BD%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"비동기 코드 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비동기 코드 테스트</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript=\"><pre class=\"language-javascript=\"><code class=\"language-javascript=\">getName: (callback) =&gt; {\n    const name = &quot;Mike&quot;\n    setTimeout(() =&gt; {\n      callback(name)\n    }, 3000)\n  }\n\ntest(&quot;3초 후에 받아온 이름은 Mike&quot;, () =&gt; {\n  const callback = (name) =&gt; {\n    expect(name).toBe(&quot;Tom&quot;)\n  }\n  fn.getName(callback)\n})//성공</code></pre></div>\n<ul>\n<li>위 코드는 성공한다.</li>\n<li>테스트를 돌려보면 3초를 기다리지 않고 success를 출력하는데, jest는 test함수의 끝에 도달하면 그대로 종료된다.</li>\n<li>비동기의 콜백을 실행되기 전에 종료되서 success를 출력하는 것임.</li>\n<li>이럴때는 테스트함수에 done이라고 하는 콜백함수를 전달해주면된다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript=\"><pre class=\"language-javascript=\"><code class=\"language-javascript=\">test(&quot;3초 후에 받아온 이름은 Mike&quot;, (done) =&gt; {\n  const callback = (name) =&gt; {\n    expect(name).toBe(&quot;Tom&quot;)\n    done()\n  }\n  fn.getName(callback)\n}) //3초 후 실패</code></pre></div>\n<ul>\n<li>콜백내의 done함수가 실행될 때까지 테스트가 종료되지 않아 비동기함수를 수행할 수 있음.</li>\n<li>\n<p>done을 전달은 받았는데 호출하지 않으면 테스트가 실패한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript=\"><pre class=\"language-javascript=\"><code class=\"language-javascript=\">getAge: (age) =&gt; {\nreturn new Promise((resolve) =&gt; {\n  setTimeout(() =&gt; {\n    resolve(age)\n  }, 3000)\n})\n}\ntest(&quot;3초 후에 받아온 age는 30&quot;, () =&gt; {\nreturn getAge(30).then((age) =&gt; {\nexpect(age).toBe(30)\n})\n})</code></pre></div>\n</li>\n<li>\n<p>promise의 경우 done을 안써도 된다. 프로미스를 return 시켜주면 됨.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript=\"><pre class=\"language-javascript=\"><code class=\"language-javascript=\">test(&quot;3초 후에 받아온 age는 30&quot;, () =&gt; {\nreturn expect(getAge(30)).resolves.toBe(30)\n})</code></pre></div>\n</li>\n<li>이렇게 사용할 수도 있음.</li>\n<li>expect(getAge(30)).rejects.toMatch(“error”)이런식으로 reject도 테스트가능함.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript=\"><pre class=\"language-javascript=\"><code class=\"language-javascript=\">test(&quot;async await&quot;,async () =&gt; {\n  const age = await getAge(30)\n  expect(age).toBe(30)\n})</code></pre></div>\n<ul>\n<li>\n<p>async await은 그냥 평소에 쓰던대로 하면 됨.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript=\"><pre class=\"language-javascript=\"><code class=\"language-javascript=\">test(&quot;3초 후에 받아온 age는 30&quot;, async () =&gt; {\nawait getAge(30).then((age) =&gt; {\nexpect(age).toBe(30)\n})\n})</code></pre></div>\n</li>\n</ul>\n<p>test(“3초 후에 받아온 age는 30”, async () => {\nawait expect(getAge(30)).resolves.toBe(30)\n})</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 위에 코드중 return 대신 await을 써도 돌아간다.\n\n\n### 테스트 전 후 작업\n- beforeEach(() =&gt; {}) : 각 테스트 실행전에 이 함수가 실행됨. 값을 초기화하기 좋음\n- afterEach : 이건 각 테스트가 끝날때마다 실행된다.\n- beforeAll / afterAll : 각 테스트 케이스마다가 실행되는게 아니라 전체 테스트가 시작하기 전 / 끝난 후에 실행됨.\n- describe를 써서 여러 테스트를 한 블록에 묶을 수 있다. \n- 이때 describe내의 before / after 함수들은 describe 내부에서만 실행 됨.\n- 근데 describe내의 테스트들은 describe 밖에서 정의한 before/after함수들도 적용된다.\n- describe 밖에있는 beforeEach가 내부의 beforeEach보다 먼저 실행됨.\n- describe 안에있는 afterEach가 외부의 afterEach보다 먼저 실행됨.\n- 밖 beforeEach -&gt; 안 beforeEach -&gt; 테스트 -&gt; 안 afterEach -&gt; 밖 afterEach\n```javascript=\ntest.only(&quot;0 + 1 = 1&quot;, () =&gt; {\n  expect(add(0, 1)).toBe(1)\n})</code></pre></div>\n<ul>\n<li>test.only는 해당 테스트만 실행되도록 한다.</li>\n<li>여러 테스트가 있는데 하나만 실패한 경우 외부의 요인인지 코드자체의 문제인지 파악할때 유용</li>\n<li>test.skip은 해당 테스트만 건너뛰도록 한다.</li>\n</ul>\n<h3 id=\"mock-함수\" style=\"position:relative;\"><a href=\"#mock-%ED%95%A8%EC%88%98\" aria-label=\"mock 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>mock 함수</h3>\n<ul>\n<li>테스트 하기 위해 흉내만 내는 함수.</li>\n<li>유저 db에 접근해서 user list를 select 해오는 작업이 필요하다면 작성해야할 코드가 상당히 많아진다.</li>\n<li>외부요인의 영향을 받기도 함(네트워크나 db환경)</li>\n<li>직접 코드를 짜는 대신 목함수로 대체함.</li>\n</ul>\n<h4 id=\"calls\" style=\"position:relative;\"><a href=\"#calls\" aria-label=\"calls permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>calls</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript=\"><pre class=\"language-javascript=\"><code class=\"language-javascript=\">const mockFn = jest.fn()\n\nmockFn()\nmockFn(1)\n\ntest(&#39;dd&#39;, () =&gt; {\n  console.log(mockFn.mock.calls) // [ [], [ 1 ] ] 출력\n  expect(&#39;dd&#39;).toBe(&#39;dd&#39;)\n})</code></pre></div>\n<ul>\n<li>jest.fn()으로 목함수 생성</li>\n<li>mockFn.mock.calls는 목함수가 실행되었을 때의 인자를 가진다.</li>\n<li>calls.length로 호출된 횟수를 테스트하거나 인자들의 값으로 테스트함</li>\n</ul>\n<p>예시</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript=\"><pre class=\"language-javascript=\"><code class=\"language-javascript=\">const mockFn = jest.fn()\n\nconst forEachAdd1 = (arr) =&gt; {\n  arr.forEach(num =&gt; {\n    //fn(num + 1)\n    mockFn(num + 1)\n  })\n}\n\nforEachAdd1([10, 20, 30]);\ntest(&#39;함수 호출은 3번 됩니다.&#39;, () =&gt; {\n  expect(mockFn.mock.calls.length).toBe(3)\n})\ntest(&#39;전달된 값은 11, 21, 31 입니다.&#39;, () =&gt; {\n  expect(mockFn.mock.calls[0][0]).toBe(11)\n  expect(mockFn.mock.calls[1][0]).toBe(21)\n  expect(mockFn.mock.calls[2][0]).toBe(31)\n})</code></pre></div>\n<ul>\n<li>배열을 순회하면서 배열값 + 1을 인자로 함수 fn을 실행시키는 forEachAdd1이라는 함수가 있고, 아직 fn이라는 함수는 만들지 않은 상태이다.</li>\n<li>fn을 만들기 전에 목함수로 호출 횟수와 전달한 인자를 테스트해서 </li>\n</ul>\n<h4 id=\"results\" style=\"position:relative;\"><a href=\"#results\" aria-label=\"results permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>results</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript=\"><pre class=\"language-javascript=\"><code class=\"language-javascript=\">const mockFn = jest.fn(num =&gt; num + 1)\n\nmockFn(10)\nmockFn(20)\nmockFn(30)\nconsole.log(mockFn.mock.results)\n/*[\n      { type: &#39;return&#39;, value: 11 },\n      { type: &#39;return&#39;, value: 21 },\n      { type: &#39;return&#39;, value: 31 }\n    ]\n*/</code></pre></div>\n<ul>\n<li>\n<p>results는 결과값을 리턴한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript=\"><pre class=\"language-javascript=\"><code class=\"language-javascript=\">const mockFn = jest.fn()</code></pre></div>\n</li>\n</ul>\n<p>mockFn\n.mockReturnValueOnce(true)\n.mockReturnValueOnce(false)\n.mockReturnValueOnce(true)\n.mockReturnValueOnce(false)\n.mockReturnValue(true)</p>\n<p>const result = [1, 2, 3, 4, 5].filter((num) => mockFn(num))</p>\n<p>test(“홀수는 1, 3, 5”, () => {\nexpect(result).toStrictEqual([1, 3, 5])\n})</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- mockReturnValueOnce는 목함수의 리턴값을 테스트 중간에 주입 가능하다.\n- 연속적으로 값을 전달하는 형태의 코드에서 효율적으로 사용 가능\n- mockResolvedValue는 비동기의 resolve를 흉내냄\n\n#### 목킹 모듈\n```javascript=\nconst { createUser } = require(&quot;./fn&quot;)\n\ntest(&#39;유저를 만든다.&#39;, () =&gt; {\n  const user = createUser(&#39;Mike&#39;)\n  expect(user.name).toBe(&#39;Mike&#39;)\n})</code></pre></div>\n<ul>\n<li>실제로 db에 유저를 생성하는 함수인 createUser 함수가 있다고 하자.</li>\n<li>테스트를 할 때마다 테스트유저를 db에 만들면 이후 직접 삭제해줘야하는 귀찮음이 있다.</li>\n<li>createUser를 mocking module로 만들어서 실제 함수를 대체한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript=\"><pre class=\"language-javascript=\"><code class=\"language-javascript=\">const { createUser } = require(&quot;./fn&quot;)\n\njest.mock(&#39;./fn&#39;)\ncreateUser.mockReturnValue({name : &#39;Mike&#39;})\n\ntest(&#39;유저를 만든다.&#39;, () =&gt; {\n  const user = createUser()\n  expect(user.name).toBe(&#39;Mike&#39;)\n})</code></pre></div>\n<ul>\n<li>위와 같이 createUser를 모킹 모듈로 만들면 실제 createUser코드는 실행되지 않고 mockReturnValue에 지정한 리턴값을 반환한다.</li>\n</ul>\n<h3 id=\"리액트-컴포넌트--스냅샷-테스트\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8--%EC%8A%A4%EB%83%85%EC%83%B7-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"리액트 컴포넌트  스냅샷 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리액트 컴포넌트 + 스냅샷 테스트</h3>\n<ul>\n<li>@testing-library/react 라이브러리로 테스트내에서 렌더링하고, 해당 스크린에 문자열을 검색하는 방식으로 테스트 할 수 있다.</li>\n<li>스냅샷은 성공하는 케이스를 저장해두고 비교하면서 테스트하는 방식이다.</li>\n<li>toMatchSnapshot() 메소드로 스냅샷을 생성하고 비교함</li>\n<li>스냅샷 업데이트는 npm test후 터미널에서 업데이트 명령어를 치면 됨</li>\n<li>만약 버그가 있어서 실패한 것인데 꼼꼼이 살펴보지않고 스냅샷을 업데이트해버리면 다음부턴 버그가 있는 스냅샷으로 테스트를 하게 되니 신중하게 선택해야 한다</li>\n<li>타이머 같은 컴포넌트는 매번 출력되는 시간이 바뀌므로 스냅샷 테스트를 할때마다 fail이 뜰 것이다.</li>\n<li>Date.now를 목함수를 써서 고정된 값으로 만든다.</li>\n</ul>","frontmatter":{"title":"jest","date":"January 14, 2021"}}},"pageContext":{"slug":"/study/jest/","previous":null,"next":{"fields":{"slug":"/etc/블로그-이전/"},"frontmatter":{"title":"블로그 이전","category":"etc","draft":false}}}},"staticQueryHashes":["3128451518","521680639"]}